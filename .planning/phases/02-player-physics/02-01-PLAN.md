---
phase: 02-player-physics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/config.js
  - js/player.js
  - js/input.js
  - js/main.js
  - js/renderer.js
autonomous: true

must_haves:
  truths:
    - "Pressing Space or ArrowUp makes a colored rectangle jump with a smooth gravity arc"
    - "Player lands on the ground and can jump again only after landing (or within coyote time window)"
    - "Player can double-jump once while airborne, with a slightly weaker second jump"
    - "Short tap produces a small hop, holding the key produces a full-height jump"
    - "Player has slight left/right movement with soft bounce at zone edges"
    - "Jump arc looks identical on 60Hz and 120Hz displays (delta-time physics)"
    - "Tapping on mobile triggers jump with variable height based on hold duration"
  artifacts:
    - path: "js/player.js"
      provides: "Player entity: physics state, update loop, jump handler, horizontal movement"
      exports: ["createPlayer", "updatePlayer", "handleJumpPress", "handleJumpRelease"]
    - path: "js/config.js"
      provides: "All player physics tuning constants"
      contains: "JUMP_CUT_MULTIPLIER"
    - path: "js/input.js"
      provides: "Upgraded input with keyup tracking and touch hold duration"
      contains: "keyup"
    - path: "js/main.js"
      provides: "Player instantiation, physics update in game loop, jump wiring, horizontal movement setup"
      contains: "updatePlayer"
    - path: "js/renderer.js"
      provides: "drawPlayer function rendering colored rectangle"
      contains: "drawPlayer"
  key_links:
    - from: "js/main.js"
      to: "js/player.js"
      via: "import createPlayer, updatePlayer, handleJumpPress, handleJumpRelease"
      pattern: "import.*from.*player"
    - from: "js/main.js"
      to: "js/renderer.js"
      via: "import drawPlayer"
      pattern: "drawPlayer"
    - from: "js/input.js"
      to: "js/main.js"
      via: "onAction and onActionRelease callbacks"
      pattern: "onAction.*onActionRelease|onJumpRelease"
    - from: "js/player.js"
      to: "js/config.js"
      via: "import CONFIG for physics constants"
      pattern: "import CONFIG from"
    - from: "js/main.js"
      to: "updatePlayer(player, deltaTime)"
      via: "game loop calls updatePlayer each frame in RUNNING state"
      pattern: "updatePlayer.*deltaTime"
    - from: "js/main.js"
      to: "js/player.js"
      via: "setupMovement sets player.velocityX on ArrowLeft/ArrowRight"
      pattern: "ArrowLeft|ArrowRight"
---

<objective>
Implement the player physics entity as a colored rectangle with gravity-based jump mechanics including double jump, variable jump height, coyote time, and horizontal movement within a zone.

Purpose: This plan delivers the core physics feel for KidneyQuest -- the jump that makes or breaks a side-scrolling runner. By using a colored rectangle first, we can verify physics feel before adding sprite complexity. All jump mechanics (variable height, double jump, coyote time, asymmetric gravity) are implemented here so the feel can be tuned via CONFIG in the browser console.
Output: A playable jumping rectangle with all Phase 2 physics features, rendered in the existing game loop.
</objective>

<execution_context>
@C:\Users\bernt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\bernt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-player-physics/02-CONTEXT.md
@.planning/phases/02-player-physics/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

@js/config.js
@js/main.js
@js/input.js
@js/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create player.js entity and upgrade config.js + input.js</name>
  <files>js/player.js, js/config.js, js/input.js</files>
  <action>
**js/config.js** -- Add these constants to the existing CONFIG default export object (keep all existing values):

```javascript
// Player physics tuning
JUMP_CUT_MULTIPLIER: 0.5,     // velocity multiplier on early jump release (short hop)
FALL_GRAVITY_MULT: 1.6,       // gravity multiplier when falling (snappier descent)
COYOTE_TIME: 0.1,             // seconds of grace period after leaving ground
DOUBLE_JUMP_MULT: 0.85,       // double jump is 85% of first jump velocity

// Player dimensions and position
PLAYER_WIDTH: 64,             // px width of player rectangle
PLAYER_HEIGHT: 80,            // px height of player rectangle
PLAYER_X_DEFAULT: 320,        // px ~25% of 1280px canvas width (default running position)
PLAYER_MOVE_SPEED: 120,       // px/s horizontal movement speed
PLAYER_MOVE_ZONE_LEFT: 160,   // px left boundary of horizontal movement zone
PLAYER_MOVE_ZONE_RIGHT: 480,  // px right boundary of horizontal movement zone
PLAYER_BOUNCE_FORCE: 0.6,     // velocity multiplier when hitting zone edges (soft bounce)

// Touch tuning
TOUCH_JUMP_SHORT_MS: 120,     // ms threshold: taps shorter than this get jump cut
```

**js/player.js** -- The existing js/player.js must be FULLY REPLACED. It uses a class-based pattern with broken named config imports (`import { GRAVITY, JUMP_VELOCITY, GROUND_Y } from './config.js'` -- but config.js uses `export default`, not named exports). Delete ALL existing content and create fresh with the factory function pattern below.

Export a factory function `createPlayer(config)` that returns a player object:

```javascript
{
  x: config.PLAYER_X_DEFAULT,
  y: config.GROUND_Y - config.PLAYER_HEIGHT,  // standing on ground
  velocityX: 0,
  velocityY: 0,
  isGrounded: true,
  jumpsRemaining: 2,        // 2 = both jumps available, 1 = used first, 0 = both used
  coyoteTimer: config.COYOTE_TIME,
  squashX: 1.0,
  squashY: 1.0,
  animState: 'idle',
  animFrame: 0,
  animTime: 0,
}
```

Export `updatePlayer(player, deltaTime)`:
1. **Horizontal movement:** Apply `player.velocityX * deltaTime` to `player.x`. Soft bounce at zone edges: if `player.x < CONFIG.PLAYER_MOVE_ZONE_LEFT`, set `player.velocityX = Math.abs(player.velocityX) * CONFIG.PLAYER_BOUNCE_FORCE`. Same for right edge with negative velocity. Clamp player.x to stay within zone (prevent escaping if deltaTime is large).
2. **Vertical physics (delta-time Euler integration):**
   - If NOT grounded: apply gravity with asymmetric multiplier. `const gravMult = player.velocityY > 0 ? CONFIG.FALL_GRAVITY_MULT : 1.0;` then `player.velocityY += CONFIG.GRAVITY * gravMult * deltaTime;`
   - Apply vertical velocity: `player.y += player.velocityY * deltaTime;`
3. **Ground collision:**
   - Calculate `groundContact = CONFIG.GROUND_Y - CONFIG.PLAYER_HEIGHT`
   - Track `wasGrounded = player.isGrounded` before checking
   - If `player.y >= groundContact`: snap to ground, zero velocityY, set isGrounded = true, reset jumpsRemaining to 2, reset coyoteTimer to CONFIG.COYOTE_TIME
   - If just landed (`!wasGrounded && player.isGrounded`): set squashX = 1.3, squashY = 0.7, set animState = 'land', reset animFrame and animTime to 0
   - If NOT on ground: set isGrounded = false, decrement coyoteTimer by deltaTime (clamp to 0)
4. **Squash/stretch spring back:** Lerp squashX and squashY back to 1.0: `player.squashX += (1.0 - player.squashX) * 12 * deltaTime;` (same for squashY)
5. **Animation state update:** Call an internal function that determines animState based on physics:
   - If animState === 'land' and it's a one-shot (track frame count): let it play out, then transition to 'run' or 'idle'
   - If grounded and Math.abs(velocityX) > 5: animState = 'run'
   - If grounded and Math.abs(velocityX) <= 5: animState = 'idle'
   - If NOT grounded and velocityY < 0 and jumpsRemaining === 1: animState = 'jump'
   - If NOT grounded and velocityY < 0 and jumpsRemaining === 0: animState = 'doubleJump'
   - If NOT grounded and velocityY >= 0: animState = 'fall'
   - On state change: reset animFrame = 0, animTime = 0

Export `handleJumpPress(player)`:
- Check `canFirstJump`: `player.coyoteTimer > 0 && player.jumpsRemaining === 2`
- Check `canDoubleJump`: `player.jumpsRemaining === 1 && !player.isGrounded`
- If canFirstJump: set velocityY = CONFIG.JUMP_VELOCITY (-650), set coyoteTimer = 0, set jumpsRemaining = 1, set isGrounded = false
- If canDoubleJump: set velocityY = CONFIG.JUMP_VELOCITY * CONFIG.DOUBLE_JUMP_MULT, set jumpsRemaining = 0
- On either jump: set animState appropriately, reset animFrame/animTime

Export `handleJumpRelease(player)`:
- If player.velocityY < 0: multiply velocityY by CONFIG.JUMP_CUT_MULTIPLIER (0.5). This cuts the jump short for variable height.

IMPORTANT: Import CONFIG from './config.js' at the top. All physics values come from CONFIG, not hardcoded numbers, so workshop participants can tune via console.

**js/input.js** -- Upgrade the existing module to support keyup events and touch hold duration.

Current input.js has setupInput(canvas, onAction) with keydown and touchstart. Modify to:

1. Change function signature to `setupInput(canvas, onAction, onActionRelease)` -- add a second callback for key/touch release.
2. Add keyup listener on canvas for Space and ArrowUp: calls `onActionRelease()`.
3. Track touch hold duration for variable jump:
   - On touchstart: record `inputState.touchStartTime = performance.now()` before calling onAction()
   - On touchend (NEW listener): calculate hold duration. If `performance.now() - inputState.touchStartTime < CONFIG.TOUCH_JUMP_SHORT_MS` (120ms), call onActionRelease() to cut the jump short. Otherwise just call onActionRelease().
   - Add the touchend listener with `{ passive: false }`.
4. Import CONFIG from './config.js' for the touch threshold.
5. Keep all existing behavior (keydown still calls onAction, touchstart still calls onAction with preventDefault).
6. Ensure the existing touchmove listener still has `{ passive: false }` with `e.preventDefault()`.

Export `inputState` as before (keep lastAction tracking). Add `touchStartTime: 0` to inputState.
  </action>
  <verify>
Read js/player.js and confirm:
1. File does NOT contain `class Player` or `import { GRAVITY` (old POC patterns fully replaced)
2. Exports createPlayer, updatePlayer, handleJumpPress, handleJumpRelease
3. createPlayer returns object with all required state fields (x, y, velocityX, velocityY, isGrounded, jumpsRemaining, coyoteTimer, squashX, squashY, animState, animFrame, animTime)
4. updatePlayer applies gravity with FALL_GRAVITY_MULT when velocityY > 0
5. updatePlayer caps player position to ground (GROUND_Y - PLAYER_HEIGHT)
6. handleJumpPress checks coyoteTimer AND jumpsRemaining atomically
7. handleJumpRelease multiplies velocityY by JUMP_CUT_MULTIPLIER when velocityY < 0
8. All physics values read from CONFIG (not hardcoded)

Read js/input.js and confirm:
1. setupInput accepts 3 params: canvas, onAction, onActionRelease
2. keyup listener exists for Space and ArrowUp
3. touchend listener exists with `{ passive: false }` and calls `e.preventDefault()`
4. touchmove listener exists with `{ passive: false }` and calls `e.preventDefault()`
5. Touch hold duration logic compares against CONFIG.TOUCH_JUMP_SHORT_MS

Read js/config.js and confirm:
1. JUMP_CUT_MULTIPLIER, FALL_GRAVITY_MULT, COYOTE_TIME, DOUBLE_JUMP_MULT exist
2. PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_X_DEFAULT exist
3. PLAYER_MOVE_SPEED, PLAYER_MOVE_ZONE_LEFT, PLAYER_MOVE_ZONE_RIGHT, PLAYER_BOUNCE_FORCE exist
4. TOUCH_JUMP_SHORT_MS exists

Read index.html and confirm:
1. Viewport meta tag contains `user-scalable=no`
  </verify>
  <done>player.js entity module created with full jump physics (double jump, variable height, coyote time, asymmetric gravity, horizontal movement); input.js upgraded with keyup and touchend tracking; config.js extended with all player constants; old class-based player.js fully replaced</done>
</task>

<task type="auto">
  <name>Task 2: Wire player into main.js and add drawPlayer to renderer.js</name>
  <files>js/main.js, js/renderer.js</files>
  <action>
**js/renderer.js** -- Add a `drawPlayer` function to the existing named exports.

`drawPlayer(ctx, player, config)`:
1. Draw as a colored rectangle for now (sprite rendering comes in Plan 02):
   - Use config.PLAYER_COLOR ('#00FF00' -- already in config)
   - Apply squash/stretch transform:
     ```javascript
     ctx.save();
     ctx.translate(player.x + config.PLAYER_WIDTH / 2, player.y + config.PLAYER_HEIGHT);
     ctx.scale(player.squashX, player.squashY);
     ctx.translate(-(config.PLAYER_WIDTH / 2), -config.PLAYER_HEIGHT);
     ctx.fillStyle = config.PLAYER_COLOR;
     ctx.fillRect(0, 0, config.PLAYER_WIDTH, config.PLAYER_HEIGHT);
     ctx.restore();
     ```
   - This anchors the squash/stretch at the bottom-center of the rectangle, so landing squash looks natural (character squishes down, not up).

Keep all existing exports (setupCanvas, resizeCanvas, clearCanvas, drawText, drawGroundLine) unchanged.

**js/main.js** -- Wire the player into the game loop. Modify the existing file.

1. **Add imports:**
   - `import { createPlayer, updatePlayer, handleJumpPress, handleJumpRelease } from './player.js';`
   - Add `drawPlayer` to the existing renderer.js import

2. **Create player instance** (after canvas setup, before game loop):
   - `const player = createPlayer(CONFIG);`

3. **Update handleAction function:**
   - Current: If READY, set to RUNNING. If GAME_OVER, set to READY.
   - Add: If RUNNING, call `handleJumpPress(player)`
   - This means Space/tap during gameplay triggers a jump.

4. **Add handleActionRelease function:**
   - Create: `function handleActionRelease() { if (gameState === 'RUNNING') handleJumpRelease(player); }`

5. **Update setupInput call:**
   - Change from `setupInput(canvas, handleAction)` to `setupInput(canvas, handleAction, handleActionRelease)`

6. **Add horizontal movement via `setupMovement(canvas, player, config)` function:**
   - Define a new function `setupMovement(canvas, player, config)` in main.js that adds keydown and keyup listeners for ArrowLeft and ArrowRight directly on the canvas element.
   - On keydown ArrowLeft: set `player.velocityX = -config.PLAYER_MOVE_SPEED`
   - On keydown ArrowRight: set `player.velocityX = config.PLAYER_MOVE_SPEED`
   - On keyup ArrowLeft: if `player.velocityX < 0`, set `player.velocityX = 0` (only stop if moving left)
   - On keyup ArrowRight: if `player.velocityX > 0`, set `player.velocityX = 0` (only stop if moving right)
   - Call `setupMovement(canvas, player, CONFIG)` after player creation.
   - This keeps input.js focused on the action callback pattern and avoids overcomplicating it. Horizontal movement is keyboard-only (CONTEXT.md decision: mobile only gets jump via tap).

7. **Update game loop (RUNNING state):**
   - Call `updatePlayer(player, deltaTime)` to advance physics
   - Call `drawPlayer(ctx, player, CONFIG)` to render the rectangle
   - Remove the ghost "Game Running..." text (replaced by the actual player)

8. **Reset player on game restart:**
   - In the GAME_OVER -> READY transition, reset the player: reassign player properties to initial values using createPlayer(CONFIG) or a reset function. Since player is `const`, use `Object.assign(player, createPlayer(CONFIG))` to reset all properties.

9. **Handle first jump from READY state:**
   - When transitioning from READY to RUNNING (Space press), the player should NOT immediately jump. The first Space press starts the game; subsequent Space presses during RUNNING trigger jumps. The current handleAction already handles this: if READY, set to RUNNING (no jump). If RUNNING, call handleJumpPress.

IMPORTANT: Do NOT break the existing start screen rendering. The READY state still shows the title and pulsing text. The RUNNING state now shows the player rectangle on the ground instead of the ghost text.
  </action>
  <verify>
Read js/main.js and confirm:
1. Contains `import { createPlayer, updatePlayer, handleJumpPress, handleJumpRelease } from './player.js'`
2. Contains `drawPlayer` in the renderer.js import
3. Contains `updatePlayer(player, deltaTime)` call inside the RUNNING state block
4. Contains `drawPlayer(ctx, player, CONFIG)` call inside the RUNNING state block
5. Contains `handleActionRelease` function that calls `handleJumpRelease(player)`
6. Contains `setupInput(canvas, handleAction, handleActionRelease)` call with 3 arguments
7. Contains a `setupMovement` function with ArrowLeft and ArrowRight keydown/keyup listeners
8. The setupMovement function sets `player.velocityX` to `config.PLAYER_MOVE_SPEED` or `-config.PLAYER_MOVE_SPEED`
9. Does NOT contain the old "Game Running..." placeholder text

Read js/renderer.js and confirm:
1. Contains `export function drawPlayer`
2. drawPlayer uses `ctx.save()`, `ctx.translate`, `ctx.scale(player.squashX, player.squashY)`, `ctx.restore()`
3. drawPlayer uses `config.PLAYER_COLOR`

<!-- Browser observation (guidance for manual testing after auto-verify passes):
Serve the project: npx http-server -p 8080 -c-1
1. Start screen still works (KidneyQuest title, pulsing text, ground line)
2. Press Space -- game transitions to RUNNING, green rectangle appears on ground
3. Press Space again -- rectangle jumps with smooth arc, falls faster than rise
4. Quick tap Space -- small hop; Hold Space -- full-height jump
5. While airborne, press Space -- double jump (slightly weaker)
6. Cannot triple-jump
7. ArrowLeft/ArrowRight move rectangle with soft bounce at zone edges
8. Rectangle squashes on landing, springs back
9. No console errors
10. CONFIG.GRAVITY = 900 in console changes jump arc
-->
  </verify>
  <done>Player rectangle is playable in the game loop with full jump physics (double jump, variable height, coyote time, asymmetric gravity, squash/stretch landing, horizontal movement via setupMovement function)</done>
</task>

</tasks>

<verification>
Phase 2 Plan 01 verification (physics foundation):
1. Green rectangle visible on ground when game is RUNNING
2. Space/ArrowUp triggers jump with smooth gravity arc
3. Short tap = small hop, hold = full jump (variable height)
4. Double jump works (one additional jump while airborne)
5. Cannot triple-jump
6. Coyote time allows late jumps (hard to test precisely, but jump from edge of ground should still work)
7. Landing produces visible squash/stretch animation
8. ArrowLeft/ArrowRight move player within zone with soft bounce at edges
9. Fall is visibly faster than rise (asymmetric gravity)
10. All values tunable via CONFIG in browser console
</verification>

<success_criteria>
- Player rectangle renders on ground at ~25% from left edge
- Jump mechanics feel snappy (fast rise, faster fall)
- Double jump is slightly weaker than first jump
- Variable jump height responds to tap duration
- Horizontal movement stays within defined zone
- Squash/stretch visible on landing
- Zero console errors
- Physics values all driven by CONFIG (tunable at runtime)
</success_criteria>

<output>
After completion, create `.planning/phases/02-player-physics/02-01-SUMMARY.md`
</output>
