---
phase: 02-player-physics
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - js/player.js
  - js/renderer.js
  - js/main.js
  - sprites/zebra.png
autonomous: false

must_haves:
  truths:
    - "A cute chibi zebra character is visible on screen instead of a colored rectangle"
    - "Zebra has a run cycle animation when grounded and moving"
    - "Zebra has distinct jump and fall poses when airborne"
    - "Zebra has a double-jump animation distinct from the first jump"
    - "Landing produces a visible squash animation on the zebra sprite"
    - "Zebra transitions smoothly between animation states (no flickering or wrong frames)"
    - "Tapping on mobile triggers jump (same as keyboard)"
  artifacts:
    - path: "sprites/zebra.png"
      provides: "Sprite sheet with animation frames for all player states"
    - path: "js/player.js"
      provides: "Animation state machine with frame advancement and one-shot handling"
      contains: "ANIM_STATES"
    - path: "js/renderer.js"
      provides: "drawPlayer using ctx.drawImage with sprite sheet cropping and squash/stretch"
      contains: "drawImage"
    - path: "js/main.js"
      provides: "Sprite sheet loading before game loop start"
      contains: "new Image"
  key_links:
    - from: "js/renderer.js"
      to: "sprites/zebra.png"
      via: "ctx.drawImage 9-param sprite sheet cropping"
      pattern: "drawImage.*spriteSheet"
    - from: "js/main.js"
      to: "js/renderer.js"
      via: "passes loaded sprite sheet Image to drawPlayer"
      pattern: "drawPlayer.*sprite"
    - from: "js/player.js"
      to: "ANIM_STATES"
      via: "animation state machine determines current row and frame"
      pattern: "ANIM_STATES\\[.*animState"
---

<objective>
Replace the colored rectangle with an animated chibi zebra sprite, including a full animation state machine for run, jump, fall, double-jump, land, and idle states.

Purpose: This plan transforms the placeholder rectangle into the game's actual character -- a cute chibi zebra. The sprite animation state machine maps directly to the physics states from Plan 01, creating visual feedback that makes the jump mechanics feel alive. The sprite sheet approach (single image, frame cropping) is the standard Canvas 2D pattern and teaches workshop participants how game character animation works.
Output: An animated zebra character with distinct poses for each movement state, rendered via sprite sheet with squash/stretch effects.
</objective>

<execution_context>
@C:\Users\bernt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\bernt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-player-physics/02-CONTEXT.md
@.planning/phases/02-player-physics/02-RESEARCH.md
@.planning/phases/02-player-physics/02-01-SUMMARY.md

@js/config.js
@js/player.js
@js/main.js
@js/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create zebra sprite sheet and implement animation state machine</name>
  <files>sprites/zebra.png, js/player.js, js/renderer.js, js/main.js</files>
  <action>
This task has two parts: creating the sprite sheet asset and wiring the animation system.

**Part A: Create the zebra sprite sheet**

Create a `sprites/` directory at the project root. The sprite sheet needs to be a single PNG image with animation frames arranged in a grid.

**Layout:** Each frame is 64px wide x 80px tall (matching CONFIG.PLAYER_WIDTH and CONFIG.PLAYER_HEIGHT). Rows represent animation states, columns represent frames within each state.

Required rows (top to bottom):
- Row 0 (idle): 4 frames -- zebra standing, subtle breathing/blinking
- Row 1 (run): 6 frames -- run cycle
- Row 2 (jump): 2 frames -- jumping upward
- Row 3 (fall): 2 frames -- falling downward
- Row 4 (land): 3 frames -- landing squash sequence
- Row 5 (doubleJump): 2 frames -- mid-air second jump (spinning or flipping)

Total sheet size: 6 columns x 6 rows = 384px wide x 480px tall (widest row is 6 frames).

**Approach for creating the sprite:** Generate the sprite sheet programmatically using Canvas 2D drawing commands. Create a helper script or inline code that draws a simple but recognizable chibi zebra character for each frame and exports to a data URL, OR draw the zebra directly in the drawPlayer function using Canvas 2D primitives (circles, rectangles, arcs) as a "procedural sprite."

**RECOMMENDED APPROACH: Procedural drawing.** Instead of depending on an external PNG file (which requires AI generation tools or manual art), draw the zebra using Canvas 2D primitives directly in the renderer. This is:
- Workshop-friendly (participants can see and modify the drawing code)
- Deterministic (no AI generation quality uncertainty)
- Zero external dependencies
- Still looks like a cute character when done well

Create a function `drawZebraFrame(ctx, frameWidth, frameHeight, animState, animFrame)` that draws a chibi zebra using Canvas 2D primitives:
- Big round head (~60% of height) with black and white stripes
- Small body below
- Simple legs that change position per frame (run cycle)
- Big eyes (two white circles with black pupils)
- Small pointy ears
- Short tail

The drawing changes per animState:
- idle: slight body bob (y offset varies per frame)
- run: legs alternate positions, body tilts slightly forward
- jump: legs tucked up, body compact, leaning upward
- fall: legs extended down, arms/ears flowing up (wind effect)
- land: squished posture (wider, shorter -- this stacks with the squashX/squashY transform)
- doubleJump: body rotated/spinning (use ctx.rotate for a partial spin per frame)

If procedural drawing is too complex, fall back to creating a simple sprite sheet PNG:
1. Use Canvas 2D to programmatically generate a sprite sheet image and save as `sprites/zebra.png`
2. OR create a minimal placeholder (colored circles with stripe patterns) as a data URL

**Part B: Animation state machine in player.js**

Add an ANIM_STATES configuration object to player.js (not exported, internal):

```javascript
const ANIM_STATES = {
  idle:       { row: 0, frames: 4, fps: 8,  loop: true  },
  run:        { row: 1, frames: 6, fps: 12, loop: true  },
  jump:       { row: 2, frames: 2, fps: 4,  loop: false },
  fall:       { row: 3, frames: 2, fps: 4,  loop: true  },
  land:       { row: 4, frames: 3, fps: 16, loop: false },
  doubleJump: { row: 5, frames: 2, fps: 6,  loop: false },
};
```

Export `ANIM_STATES` so renderer.js can access frame counts and row info.

Update the animation state logic in `updatePlayer` (the part from Plan 01 that sets animState):
- When animState changes, reset animFrame = 0 and animTime = 0 (prevents frame bleeding between states -- Pitfall 4 from RESEARCH.md)
- Frame advancement: `player.animTime += deltaTime; if (player.animTime >= 1 / anim.fps) { player.animTime -= 1 / anim.fps; player.animFrame++; }`
- For looping states: `player.animFrame %= anim.frames`
- For one-shot states (land, jump, doubleJump with loop: false): when animFrame reaches frames - 1, hold on last frame. For 'land' specifically, transition to 'run' or 'idle' after last frame plays.

**Part C: Update drawPlayer in renderer.js**

Replace the colored rectangle rendering with sprite-based rendering.

If using procedural drawing approach:
```javascript
export function drawPlayer(ctx, player, config) {
  ctx.save();
  // Apply squash/stretch anchored at bottom-center
  ctx.translate(player.x + config.PLAYER_WIDTH / 2, player.y + config.PLAYER_HEIGHT);
  ctx.scale(player.squashX, player.squashY);
  ctx.translate(-(config.PLAYER_WIDTH / 2), -config.PLAYER_HEIGHT);

  // Draw the zebra using Canvas 2D primitives
  drawZebraFrame(ctx, config.PLAYER_WIDTH, config.PLAYER_HEIGHT, player.animState, player.animFrame);

  ctx.restore();
}
```

If using sprite sheet PNG approach:
```javascript
export function drawPlayer(ctx, player, config, spriteSheet) {
  if (!spriteSheet || !spriteSheet.complete) {
    // Fallback to colored rectangle if sprite not loaded
    ctx.save();
    ctx.translate(player.x + config.PLAYER_WIDTH / 2, player.y + config.PLAYER_HEIGHT);
    ctx.scale(player.squashX, player.squashY);
    ctx.translate(-(config.PLAYER_WIDTH / 2), -config.PLAYER_HEIGHT);
    ctx.fillStyle = config.PLAYER_COLOR;
    ctx.fillRect(0, 0, config.PLAYER_WIDTH, config.PLAYER_HEIGHT);
    ctx.restore();
    return;
  }

  const anim = ANIM_STATES[player.animState];
  const srcX = player.animFrame * config.PLAYER_WIDTH;
  const srcY = anim.row * config.PLAYER_HEIGHT;

  ctx.save();
  ctx.translate(player.x + config.PLAYER_WIDTH / 2, player.y + config.PLAYER_HEIGHT);
  ctx.scale(player.squashX, player.squashY);
  ctx.translate(-(config.PLAYER_WIDTH / 2), -config.PLAYER_HEIGHT);

  ctx.drawImage(
    spriteSheet,
    srcX, srcY, config.PLAYER_WIDTH, config.PLAYER_HEIGHT,
    0, 0, config.PLAYER_WIDTH, config.PLAYER_HEIGHT
  );

  ctx.restore();
}
```

IMPORTANT: Always include the colored rectangle fallback. If the sprite sheet fails to load or is missing, the game should still be playable with the green rectangle from Plan 01.

**Part D: Load sprite sheet in main.js (only if using PNG approach)**

If using a sprite sheet PNG, add image loading in main.js before the game loop:

```javascript
const spriteSheet = new Image();
spriteSheet.src = 'sprites/zebra.png';
// Game loop runs regardless -- drawPlayer handles missing sprite gracefully
```

Pass `spriteSheet` to `drawPlayer(ctx, player, CONFIG, spriteSheet)` in the game loop.

If using the procedural drawing approach, no image loading is needed -- the drawZebraFrame function handles everything with Canvas 2D primitives.

**Decision for implementer:** Choose procedural drawing (Canvas 2D primitives) if you can make a recognizable cute zebra. Choose PNG sprite sheet if procedural drawing would take too long or look too basic. Either approach is valid. The procedural approach is preferred for workshop explainability.
  </action>
  <verify>
Serve the project and open in browser.

Check:
1. A zebra character (not a plain rectangle) is visible on the ground when RUNNING
2. Zebra has visible animation when standing (idle breathing/bob) or running (leg movement)
3. Jump produces a distinct upward pose
4. Falling shows a different pose than jumping
5. Double-jump shows a unique animation (spin or flip)
6. Landing shows a brief squash effect then transitions to run/idle
7. No sprite flickering or wrong frames during state transitions
8. Start screen still works correctly (no regression)
9. All jump physics from Plan 01 still work identically
10. No console errors
11. If sprite sheet approach: temporarily rename/delete sprites/zebra.png and reload -- should fall back to green rectangle
  </verify>
  <done>Zebra character with full animation state machine replaces colored rectangle; all physics from Plan 01 preserved; fallback to rectangle if sprite is unavailable</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 2 player: a chibi zebra character with gravity-based jump mechanics including double jump, variable jump height (short tap vs hold), coyote time, asymmetric gravity (faster fall), landing squash/stretch, horizontal movement with soft bounce, and a full animation state machine (idle, run, jump, fall, double-jump, land).</what-built>
  <how-to-verify>
1. Open http://localhost:8080 in a browser
2. Confirm start screen still shows KidneyQuest title and pulsing "Press Space to Start"
3. Press Space to start -- zebra character appears on the ground
4. Observe the zebra has an idle or run animation (not a static image)
5. Press Space -- zebra jumps with a smooth, snappy arc (fast up, faster down)
6. Quick-tap Space -- zebra does a small hop (variable jump height)
7. Hold Space -- zebra does a full-height jump
8. While airborne, press Space again -- zebra double-jumps with a distinct animation
9. Try pressing Space a third time while airborne -- nothing happens (no triple-jump)
10. Watch the landing -- zebra briefly squashes (wider, shorter) then springs back
11. Press ArrowLeft/ArrowRight -- zebra moves horizontally, bounces softly at zone edges
12. Open browser console: type `CONFIG.GRAVITY = 500` -- jump becomes floatier
13. Type `CONFIG.JUMP_VELOCITY = -900` -- jump goes much higher
14. (Optional) Test on mobile or DevTools mobile emulation: tap to jump, hold for higher jump
15. Verify the zebra looks cute/chibi and appropriate for a workshop game
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with jump feel, animation, or visual appearance</resume-signal>
</task>

</tasks>

<verification>
Phase 2 success criteria (from ROADMAP.md):
1. Pressing Space or ArrowUp (or tapping on mobile) makes the player character jump with a smooth gravity arc
2. Player lands back on the ground and cannot jump again until grounded (except double-jump while airborne)
3. Jump arc looks and feels identical on 60Hz and 120Hz displays (delta-time physics)

Additional criteria from CONTEXT.md decisions:
4. Double jump enabled -- one additional jump while airborne
5. Variable jump height -- short tap = small hop, hold = full jump
6. Coyote time -- ~100ms grace period
7. Animated zebra sprite with distinct states (idle, run, jump, fall, double-jump, land)
8. Horizontal movement within zone with soft bounce
</verification>

<success_criteria>
- Chibi zebra character visible and animated (not a colored rectangle)
- All 6 animation states visually distinct (idle, run, jump, fall, doubleJump, land)
- Jump feels snappy (Mario-like: fast rise, faster fall)
- Double jump works with slightly weaker arc
- Variable jump height responds to tap/hold duration
- Landing squash/stretch is visible and springs back smoothly
- Horizontal movement stays within zone with soft bounce
- Physics tunable via CONFIG in browser console
- Fallback to colored rectangle if sprite is unavailable
- Zero console errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-player-physics/02-02-SUMMARY.md`
</output>
