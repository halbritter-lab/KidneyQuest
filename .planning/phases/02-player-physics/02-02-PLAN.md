---
phase: 02-player-physics
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - js/player.js
  - js/renderer.js
  - js/main.js
autonomous: false

must_haves:
  truths:
    - "A cute chibi zebra character is visible on screen instead of a colored rectangle"
    - "Zebra has a run cycle animation when grounded and moving"
    - "Zebra has distinct jump and fall poses when airborne"
    - "Zebra has a double-jump animation distinct from the first jump"
    - "Landing produces a visible squash animation on the zebra sprite"
    - "Zebra transitions smoothly between animation states (no flickering or wrong frames)"
    - "Sprite rendering degrades gracefully to colored rectangle if procedural drawing fails to render"
  artifacts:
    - path: "js/player.js"
      provides: "ANIM_STATES config (internal, not exported) and animation frame advancement in updatePlayer"
      contains: "ANIM_STATES"
    - path: "js/renderer.js"
      provides: "drawZebraFrame procedural drawing function and updated drawPlayer that calls it"
      contains: "drawZebraFrame"
    - path: "js/main.js"
      provides: "No image loading needed -- procedural approach requires no changes to main.js beyond what Plan 01 provides"
  key_links:
    - from: "js/renderer.js"
      to: "js/player.js"
      via: "drawPlayer reads player.animState and player.animFrame to select pose"
      pattern: "player\\.animState|player\\.animFrame"
    - from: "js/renderer.js"
      to: "drawZebraFrame"
      via: "drawPlayer calls drawZebraFrame(ctx, width, height, animState, animFrame)"
      pattern: "drawZebraFrame"
    - from: "js/player.js"
      to: "ANIM_STATES"
      via: "updatePlayer uses ANIM_STATES internally for frame advancement and one-shot handling"
      pattern: "ANIM_STATES\\[.*animState"
---

<objective>
Replace the colored rectangle with an animated chibi zebra drawn procedurally using Canvas 2D primitives, including a full animation state machine for run, jump, fall, double-jump, land, and idle states.

Purpose: This plan transforms the placeholder rectangle into the game's actual character -- a cute chibi zebra. The procedural drawing approach (Canvas 2D primitives) is workshop-friendly: participants can see and modify the drawing code, it requires zero external assets, and it's deterministic. The animation state machine maps directly to the physics states from Plan 01, creating visual feedback that makes the jump mechanics feel alive.
Output: An animated zebra character with distinct poses for each movement state, rendered via Canvas 2D procedural drawing with squash/stretch effects and graceful fallback to colored rectangle.
</objective>

<execution_context>
@C:\Users\bernt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\bernt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-player-physics/02-CONTEXT.md
@.planning/phases/02-player-physics/02-RESEARCH.md
@.planning/phases/02-player-physics/02-01-SUMMARY.md

@js/config.js
@js/player.js
@js/main.js
@js/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ANIM_STATES and frame advancement logic to player.js</name>
  <files>js/player.js</files>
  <action>
Add an ANIM_STATES configuration object to player.js. This is INTERNAL to the module -- do NOT export it. The procedural drawing in renderer.js does not need ANIM_STATES; it receives animState and animFrame as parameters and handles pose mapping internally.

```javascript
const ANIM_STATES = {
  idle:       { frames: 4, fps: 8,  loop: true  },
  run:        { frames: 6, fps: 12, loop: true  },
  jump:       { frames: 2, fps: 4,  loop: false },
  fall:       { frames: 2, fps: 4,  loop: true  },
  land:       { frames: 3, fps: 16, loop: false },
  doubleJump: { frames: 2, fps: 6,  loop: false },
};
```

Note: No `row` field needed -- we are NOT using a sprite sheet. The `frames` count tells the frame advancement logic how many frames exist, and the renderer uses animState + animFrame to determine what to draw.

Update the animation state logic in `updatePlayer` (the part from Plan 01 that sets animState):
- When animState changes, reset animFrame = 0 and animTime = 0 (prevents frame bleeding between states -- Pitfall 4 from RESEARCH.md)
- Frame advancement: `player.animTime += deltaTime; const anim = ANIM_STATES[player.animState]; if (anim && player.animTime >= 1 / anim.fps) { player.animTime -= 1 / anim.fps; player.animFrame++; }`
- For looping states: `player.animFrame %= anim.frames`
- For one-shot states (land, jump, doubleJump with loop: false): when animFrame reaches `anim.frames - 1`, hold on last frame. For 'land' specifically, after last frame plays out (detect via animTime accumulation or a flag), transition animState to 'run' (if moving) or 'idle' (if stationary).
- Add a guard: if `player.animState` is not in ANIM_STATES, default to 'idle' to prevent crashes.

The animation frame advancement should be placed AFTER the existing physics and animation state determination logic in updatePlayer, so that the frame counter is always in sync with the current state.
  </action>
  <verify>
Read js/player.js and confirm:
1. Contains `const ANIM_STATES` (NOT `export const ANIM_STATES`)
2. ANIM_STATES has entries for: idle, run, jump, fall, land, doubleJump
3. Each ANIM_STATES entry has `frames`, `fps`, and `loop` properties
4. updatePlayer contains frame advancement logic: `player.animTime += deltaTime` and `player.animFrame++`
5. updatePlayer contains loop handling: `player.animFrame %= anim.frames` for looping states
6. updatePlayer contains one-shot handling: holds on last frame for non-looping states
7. 'land' state transitions to 'run' or 'idle' after animation completes
8. animFrame and animTime are reset to 0 when animState changes
  </verify>
  <done>ANIM_STATES defined internally in player.js with frame counts and fps for all 6 animation states; updatePlayer advances animation frames with proper loop/one-shot handling and state-change resets</done>
</task>

<task type="auto">
  <name>Task 2: Implement drawZebraFrame procedural drawing in renderer.js</name>
  <files>js/renderer.js</files>
  <action>
Add a `drawZebraFrame(ctx, frameWidth, frameHeight, animState, animFrame)` function to renderer.js. This function draws a chibi zebra character using Canvas 2D primitives (no external images, no sprite sheet).

**Character design (chibi proportions):**
- Big round head: ~55-60% of total height, centered horizontally
- Head has black and white zebra stripes (2-3 diagonal black stripes on white)
- Two big white eyes with black pupils (positioned upper third of head)
- Small pointy triangular ears on top
- Small rectangular body below head: ~25% of total height
- Short stubby legs: ~15% of total height, 2 front + 2 back (or simplified to 2 visible in side view)
- Short tail (small curved line from back of body)
- Body color: white (#FFFFFF) with black (#000000) stripes and outlines
- Accent: a small pink nose or inner ear detail for cuteness

**Pose variations by animState and animFrame:**

`idle` (4 frames):
- Frame 0-3: subtle body bob. Vary the y-offset of the entire body by +/- 2px using a sine-like pattern (frame 0: 0px, frame 1: -2px, frame 2: 0px, frame 3: +1px). Ears wiggle slightly. Pupils shift slightly between frames.

`run` (6 frames):
- Legs alternate positions in a walk/run cycle. Frame 0: left-front extended, right-back extended. Frame 1: legs closer together. Frame 2: right-front extended, left-back extended. Etc.
- Body tilts slightly forward (~3 degrees via ctx.rotate)
- Tail bounces up/down slightly per frame

`jump` (2 frames):
- Frame 0: legs tucked up close to body (shorter leg rectangles, moved up)
- Frame 1: body stretching upward, ears pointed up
- Body compact, leaning slightly upward

`fall` (2 frames):
- Frame 0: legs extended downward, ears flowing up (wind effect -- ears tilted back)
- Frame 1: slight variation on leg position
- Body slightly elongated vertically

`land` (3 frames):
- Frame 0: maximum squish (wider, shorter posture -- this stacks with squashX/squashY transform)
- Frame 1: partial recovery
- Frame 2: nearly back to normal standing pose

`doubleJump` (2 frames):
- Frame 0: body rotated ~90 degrees (use `ctx.rotate(Math.PI / 2)` relative to center)
- Frame 1: body rotated ~180 degrees (partial spin effect)
- This gives a spinning visual for the double-jump

**Implementation approach:**
- Use `ctx.beginPath()`, `ctx.arc()`, `ctx.fillRect()`, `ctx.fill()`, `ctx.stroke()` etc.
- Draw from bottom-up: legs first, then body, then head, then details (eyes, ears, stripes)
- All coordinates relative to (0, 0) at top-left of the frameWidth x frameHeight box (the caller handles positioning via translate)
- Keep drawing code clean and commented -- workshop participants will read this

**Update drawPlayer in renderer.js:**

Replace the colored rectangle rendering with the procedural zebra drawing. Wrap the zebra drawing in a try-catch so that if any drawing error occurs, it falls back to the colored rectangle:

```javascript
export function drawPlayer(ctx, player, config) {
  ctx.save();
  // Apply squash/stretch anchored at bottom-center
  ctx.translate(player.x + config.PLAYER_WIDTH / 2, player.y + config.PLAYER_HEIGHT);
  ctx.scale(player.squashX, player.squashY);
  ctx.translate(-(config.PLAYER_WIDTH / 2), -config.PLAYER_HEIGHT);

  try {
    drawZebraFrame(ctx, config.PLAYER_WIDTH, config.PLAYER_HEIGHT, player.animState, player.animFrame);
  } catch (e) {
    // Fallback to colored rectangle if procedural drawing fails
    ctx.fillStyle = config.PLAYER_COLOR;
    ctx.fillRect(0, 0, config.PLAYER_WIDTH, config.PLAYER_HEIGHT);
  }

  ctx.restore();
}
```

Keep all existing exports (setupCanvas, resizeCanvas, clearCanvas, drawText, drawGroundLine) unchanged. drawZebraFrame does NOT need to be exported -- it is called only by drawPlayer within the same module.

No changes needed to main.js -- the existing `drawPlayer(ctx, player, CONFIG)` call from Plan 01 works as-is since the function signature is unchanged.
  </action>
  <verify>
Read js/renderer.js and confirm:
1. Contains `function drawZebraFrame(ctx, frameWidth, frameHeight, animState, animFrame)`
2. drawZebraFrame uses Canvas 2D primitives: `ctx.arc`, `ctx.fillRect`, `ctx.beginPath`, `ctx.fill` (at least some of these)
3. drawZebraFrame has branching logic for at least: idle, run, jump, fall, land, doubleJump
4. drawPlayer contains try-catch wrapping the drawZebraFrame call
5. drawPlayer catch block falls back to `ctx.fillStyle = config.PLAYER_COLOR` + `ctx.fillRect`
6. drawPlayer still applies squash/stretch via `ctx.scale(player.squashX, player.squashY)`
7. drawPlayer reads `player.animState` and `player.animFrame` and passes them to drawZebraFrame
8. No `import` of ANIM_STATES from player.js (ANIM_STATES is internal to player.js)
9. No reference to `spriteSheet`, `new Image()`, or `drawImage` with 9 params (no sprite sheet approach)
  </verify>
  <done>Procedural chibi zebra rendering implemented with Canvas 2D primitives; all 6 animation states have distinct visual poses; drawPlayer wraps zebra drawing in try-catch with colored rectangle fallback; no external image dependencies</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 2 player: a chibi zebra character drawn with Canvas 2D primitives, with gravity-based jump mechanics including double jump, variable jump height (short tap vs hold), coyote time, asymmetric gravity (faster fall), landing squash/stretch, horizontal movement with soft bounce, and a full animation state machine (idle, run, jump, fall, double-jump, land).</what-built>
  <how-to-verify>
1. Open http://localhost:8080 in a browser
2. Confirm start screen still shows KidneyQuest title and pulsing "Press Space to Start"
3. Press Space to start -- zebra character appears on the ground
4. Observe the zebra has an idle or run animation (not a static image)
5. Press Space -- zebra jumps with a smooth, snappy arc (fast up, faster down)
6. Quick-tap Space -- zebra does a small hop (variable jump height)
7. Hold Space -- zebra does a full-height jump
8. While airborne, press Space again -- zebra double-jumps with a distinct animation (spin)
9. Try pressing Space a third time while airborne -- nothing happens (no triple-jump)
10. Watch the landing -- zebra briefly squashes (wider, shorter) then springs back
11. Press ArrowLeft/ArrowRight -- zebra moves horizontally, bounces softly at zone edges
12. Open browser console: type `CONFIG.GRAVITY = 500` -- jump becomes floatier
13. Type `CONFIG.JUMP_VELOCITY = -900` -- jump goes much higher
14. (Optional) Test on mobile or DevTools mobile emulation: tap to jump, hold for higher jump
15. Verify the zebra looks cute/chibi and appropriate for a workshop game
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with jump feel, animation, or visual appearance</resume-signal>
</task>

</tasks>

<verification>
Phase 2 success criteria (from ROADMAP.md):
1. Pressing Space or ArrowUp (or tapping on mobile) makes the player character jump with a smooth gravity arc
2. Player lands back on the ground and cannot jump again until grounded (except double-jump while airborne)
3. Jump arc looks and feels identical on 60Hz and 120Hz displays (delta-time physics)

Additional criteria from CONTEXT.md decisions:
4. Double jump enabled -- one additional jump while airborne
5. Variable jump height -- short tap = small hop, hold = full jump
6. Coyote time -- ~100ms grace period
7. Animated zebra sprite with distinct states (idle, run, jump, fall, double-jump, land)
8. Horizontal movement within zone with soft bounce
</verification>

<success_criteria>
- Chibi zebra character visible and animated (not a colored rectangle)
- All 6 animation states visually distinct (idle, run, jump, fall, doubleJump, land)
- Jump feels snappy (Mario-like: fast rise, faster fall)
- Double jump works with slightly weaker arc
- Variable jump height responds to tap/hold duration
- Landing squash/stretch is visible and springs back smoothly
- Horizontal movement stays within zone with soft bounce
- Physics tunable via CONFIG in browser console
- Graceful fallback to colored rectangle if procedural drawing errors
- Zero console errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-player-physics/02-02-SUMMARY.md`
</output>
