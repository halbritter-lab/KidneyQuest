# Phase 2: Player + Physics - Research

**Researched:** 2026-02-18
**Domain:** HTML5 Canvas 2D game physics, sprite animation, jump mechanics, AI sprite generation
**Confidence:** MEDIUM-HIGH (physics patterns verified via multiple sources; sprite generation via official docs)

## Summary

This phase introduces the player entity to KidneyQuest: a chibi zebra character with gravity-based jump mechanics rendered on the existing HTML5 Canvas 2D game loop from Phase 1. Research covered four domains: (1) delta-time jump physics with coyote time and variable jump height, (2) sprite sheet animation state machines for Canvas 2D, (3) generating zebra sprites using the Nano Banana Gemini CLI extension, and (4) game design standards for character sizing and ground positioning in side-scrolling runners.

The existing `CONFIG` already contains strong starting values (GRAVITY: 1800 px/s², JUMP_VELOCITY: -650 px/s, GROUND_Y: 600 on a 1280x720 canvas). These align with verified game design standards for a snappy, Mario-like feel. The primary technical challenge is implementing variable jump height and coyote time correctly with delta-time physics so behavior is identical at 60Hz and 120Hz. The sprite animation layer adds complexity via a state machine (idle/run/jump/fall/land/double-jump) and sprite sheet loading.

For sprite creation, the Nano Banana Gemini CLI extension (`gemini-cli-extensions/nanobanana`) is the correct tool — NOT "nanano banana," which appears to be a misremembering of the name. The tool is real, well-documented, and capable of generating sprite sheets from text prompts. It requires a Google API key and Node.js 20+.

**Primary recommendation:** Implement physics first with placeholder rectangles to verify feel, then layer the sprite animation state machine on top. Use the Nano Banana extension to generate the zebra sprite sheet after physics feel is confirmed.

## Standard Stack

This phase uses no external libraries. All implementation is vanilla JavaScript on the Canvas 2D API already established in Phase 1.

### Core

| Tool | Version | Purpose | Why Standard |
|------|---------|---------|--------------|
| Canvas 2D API (`ctx.drawImage`) | Browser native | Sprite sheet frame rendering | Already in use; 9-param drawImage supports sprite cropping |
| `requestAnimationFrame` | Browser native | Game loop with timestamp | Already established in main.js |
| Nano Banana (Gemini CLI extension) | Latest | AI sprite sheet generation | Verified: official Google AI image model, CLI extension available |

### Supporting

| Tool | Version | Purpose | When to Use |
|------|---------|---------|-------------|
| `gemini extensions install nanobanana` | Latest | Install Nano Banana in terminal | Sprite generation step |
| Piskel (online editor) | Web-based | Manual pixel art editing if AI output needs cleanup | Post-generation frame cleanup |
| OpenGameArt.org | N/A | Free licensed fallback sprites | If AI generation produces unusable output |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Nano Banana AI generation | Hand-drawn in Piskel | Piskel gives full control but requires art skill; Nano Banana is faster for workshop demos |
| Nano Banana AI generation | OpenGameArt.org pre-made assets | Pre-made assets won't be zebra/chibi but are zero-effort fallback |
| Custom physics code | Matter.js or Planck.js | External physics engines add dependencies; for a simple runner the custom approach is standard and workshop-explainable |

**Installation (Nano Banana):**
```bash
# Requires Gemini CLI and Node.js 20+
gemini extensions install https://github.com/gemini-cli-extensions/nanobanana
export NANOBANANA_GEMINI_API_KEY="your-google-api-key"
# Then inside Gemini CLI:
/generate "6-frame side-view run cycle of a cute chibi zebra character, horizontal sprite sheet, transparent background, consistent frame size 80x80px"
```

## Architecture Patterns

### Recommended Project Structure

The phase adds two new files and modifies three existing ones:

```
js/
├── config.js        # Add: PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_X_DEFAULT,
│                    #      JUMP_CUT_MULTIPLIER, COYOTE_TIME, FALL_GRAVITY_MULT
├── player.js        # NEW: Player entity (physics state + animation state machine)
├── renderer.js      # Add: drawPlayer() function
├── input.js         # Modify: track keydown duration (for variable jump) + keyup event
├── main.js          # Modify: instantiate player, update physics, handle jump action
└── sprites/
    └── zebra.png    # NEW: Sprite sheet generated by Nano Banana
```

### Pattern 1: Delta-Time Physics with Euler Integration

**What:** Apply gravity and velocity per frame using elapsed seconds, not frame count.
**When to use:** Always. This is the only approach that guarantees identical behavior at 60Hz and 120Hz.

```javascript
// Source: jobtalle.com/2d_platformer_physics.html + Phase 1 main.js pattern
// In player.update(deltaTime):

// Apply gravity (with fall multiplier for snappy feel)
if (!player.isGrounded) {
  // Fall faster than you rise (Mario feel)
  const gravMultiplier = player.velocityY > 0 ? CONFIG.FALL_GRAVITY_MULT : 1.0;
  player.velocityY += CONFIG.GRAVITY * gravMultiplier * deltaTime;
}

// Apply velocity to position
player.y += player.velocityY * deltaTime;

// Ground collision
if (player.y >= CONFIG.GROUND_Y - CONFIG.PLAYER_HEIGHT) {
  player.y = CONFIG.GROUND_Y - CONFIG.PLAYER_HEIGHT;
  player.velocityY = 0;
  player.isGrounded = true;
  player.jumpsRemaining = 2; // Reset double-jump counter
  player.coyoteTimer = CONFIG.COYOTE_TIME;
}
```

**Critical:** deltaTime must be capped at 0.1s (already done in main.js) to prevent physics explosion after tab switch.

### Pattern 2: Variable Jump Height via Velocity Cutoff

**What:** On jump key release, multiply upward velocity by a cutoff factor to end the jump early.
**When to use:** This produces short-tap = small hop, hold = full jump without timing complexity.

```javascript
// Source: pavcreations.com, gamemakerkitchen.com findings
// In input.js or main.js on keyup/touchend:

function onJumpReleased() {
  if (player.velocityY < 0) {
    // Cut the jump short — multiply upward velocity by cutoff factor
    player.velocityY *= CONFIG.JUMP_CUT_MULTIPLIER; // recommended: 0.5
  }
}
```

**Note:** For touch, track `touchStartTime` on touchstart and determine hold duration on touchend. Apply jump cut if duration was short (< 120ms threshold). This approximates the hold mechanic for mobile.

### Pattern 3: Coyote Time

**What:** Allow jumping for a brief window (100ms) after leaving the ground without jumping.
**When to use:** Every time player leaves a ledge — standard in all modern platformers.

```javascript
// Source: gameidea.org/2025/08/02/make-platformer-jump-feel-satisfying-using-coyote-timer/

// In player.update(deltaTime):
if (player.isGrounded) {
  player.coyoteTimer = CONFIG.COYOTE_TIME; // reset to 0.1
} else {
  player.coyoteTimer = Math.max(0, player.coyoteTimer - deltaTime);
}

// In jump handler:
function tryJump() {
  const canFirstJump = player.coyoteTimer > 0 && player.jumpsRemaining === 2;
  const canDoubleJump = !player.isGrounded && player.jumpsRemaining === 1;

  if (canFirstJump) {
    player.velocityY = CONFIG.JUMP_VELOCITY;
    player.coyoteTimer = 0;
    player.jumpsRemaining = 1;
  } else if (canDoubleJump) {
    player.velocityY = CONFIG.JUMP_VELOCITY * 0.85; // double jump slightly weaker
    player.jumpsRemaining = 0;
  }
}
```

### Pattern 4: Sprite Animation State Machine

**What:** Track which animation state the player is in and advance frames at the correct rate.
**When to use:** Whenever sprites need to vary by physics state (grounded/airborne/landing).

```javascript
// Source: spicyyoghurt.com sprite animation tutorial

const ANIM_STATES = {
  idle:        { row: 0, frames: 4,  fps: 8  },
  run:         { row: 1, frames: 6,  fps: 12 },
  jump:        { row: 2, frames: 2,  fps: 4  },
  fall:        { row: 3, frames: 2,  fps: 4  },
  land:        { row: 4, frames: 3,  fps: 16 },  // plays once then transitions to run
  doubleJump:  { row: 5, frames: 2,  fps: 6  },
};

// drawImage for sprite frame:
// ctx.drawImage(
//   spriteSheet,
//   col * FRAME_W, row * FRAME_H,   // source x, y
//   FRAME_W, FRAME_H,               // source w, h
//   destX, destY,                   // destination x, y
//   FRAME_W, FRAME_H                // destination w, h
// );
```

**Animation state transitions:**
- isGrounded + velocityX ~= 0 → idle
- isGrounded + velocityX > 0 → run
- !isGrounded + velocityY < 0 + jumpsRemaining === 1 → jump
- !isGrounded + velocityY < 0 + jumpsRemaining === 0 → doubleJump
- !isGrounded + velocityY >= 0 → fall
- just landed (isGrounded transitioned from false) → land (play once, 3 frames, then → run)

### Pattern 5: Squash and Stretch on Landing

**What:** Briefly scale the sprite wide and short on landing, then spring back.
**When to use:** Landing transition; adds juice without requiring extra sprite frames.

```javascript
// Source: canvas API ctx.save/scale pattern (MEDIUM confidence)
// In renderer drawPlayer():

ctx.save();
ctx.translate(player.x + FRAME_W / 2, player.y + FRAME_H); // anchor bottom-center
ctx.scale(player.squashX, player.squashY);                  // squashX=1.3, squashY=0.7 on land
ctx.translate(-(FRAME_W / 2), -FRAME_H);
ctx.drawImage(spriteSheet, srcX, srcY, FRAME_W, FRAME_H, 0, 0, FRAME_W, FRAME_H);
ctx.restore();

// player.squashX and player.squashY lerp back to 1.0 each frame:
player.squashX += (1.0 - player.squashX) * 12 * deltaTime;
player.squashY += (1.0 - player.squashY) * 12 * deltaTime;
```

### Recommended CONFIG Additions

The existing CONFIG has good base values. Add these:

```javascript
// Physics feel tuning
JUMP_CUT_MULTIPLIER: 0.5,     // velocity multiplier on early jump release
FALL_GRAVITY_MULT: 1.6,       // gravity multiplier when falling (snappier descent)
COYOTE_TIME: 0.1,             // seconds of grace period after leaving ground
DOUBLE_JUMP_MULT: 0.85,       // double jump is 85% of first jump velocity

// Player dimensions (see sizing recommendation below)
PLAYER_WIDTH: 64,             // px sprite frame width
PLAYER_HEIGHT: 80,            // px sprite frame height (chibi: taller than wide)
PLAYER_X_DEFAULT: 320,        // px ~25% of 1280px canvas width
PLAYER_MOVE_SPEED: 120,       // px/s horizontal movement speed
PLAYER_MOVE_ZONE_LEFT: 160,   // px left boundary of horizontal zone
PLAYER_MOVE_ZONE_RIGHT: 480,  // px right boundary of horizontal zone
PLAYER_BOUNCE_FORCE: 0.6,     // velocity multiplier when hitting zone edges
```

### Player Size Recommendation (Claude's Discretion)

**Recommendation: 64px wide, 80px tall sprite frames. Draw height of ~80px on canvas.**

Rationale based on research:
- Canvas is 1280x720. Ground is at Y=600. Play area height = 600px.
- Character should occupy ~10-15% of play area height for good visibility: 600 * 0.13 ≈ 78px.
- Chibi proportions (big head, small body) work well at 64x80 — head fills ~50% of height.
- The Chrome Dino game character occupies ~12% of screen height (reference standard).
- At 64px wide, about 20 characters could fit horizontally — good for obstacle spacing later.
- Sprite sits with its bottom edge at GROUND_Y (y = GROUND_Y - PLAYER_HEIGHT = 600 - 80 = 520).

### Ground Height Recommendation (Claude's Discretion)

**Recommendation: Keep GROUND_Y at 600 (already set in Phase 1).**

Rationale:
- 600/720 = 83% down the canvas — leaves 120px below the player landing zone.
- The filled ground area (600 to 720 = 120px) provides a visible, solid ground presence.
- This matches the Phase 1 decision and is a good standard for side-scrollers.
- No change needed.

### Anti-Patterns to Avoid

- **Frame-based physics:** Never do `player.y += player.velocityY` without `* deltaTime`. At 120Hz this runs twice as fast as 60Hz.
- **Single-jump-on-ground check only:** Detect ground by position comparison (`player.y >= GROUND_Y - PLAYER_HEIGHT`), not by collision events — keeps it simple and delta-time safe.
- **Infinite jumps:** Always check `jumpsRemaining > 0` before applying any jump, including coyote time.
- **Blocking animation transitions:** The land animation must auto-transition to run after playing once (track frame index reaching end).
- **Forgetting to reset coyoteTimer on jump:** If coyote timer fires a jump but the player also has `jumpsRemaining === 2`, they'd get 3 jumps total. Reset coyoteTimer to 0 immediately after using it.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| AI sprite generation | Custom image tools | Nano Banana Gemini CLI extension | Officially supported, generates PNG sprite sheets from text prompts in seconds |
| Sprite sheet cropping | Custom blit system | Native `ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh)` | 9-param version handles all sprite sheet cropping natively |
| Frame timing per animation | Custom timer per state | Accumulate `animTime += deltaTime`, advance frame when `animTime >= 1/fps` | Simple, robust, no extra dependencies |
| Touch hold duration | Separate touch library | `touchstart` → record `Date.now()`, `touchend` → calculate duration | Two events, no library needed |

**Key insight:** The Canvas 2D API already has everything needed for sprite animation. The only genuinely new capability is AI sprite generation via Nano Banana.

## Common Pitfalls

### Pitfall 1: Variable Jump Height with Touch

**What goes wrong:** Touch events fire `touchstart` and `touchend` — but there's no `keyup` equivalent that fires while still holding. The "hold = higher jump" logic for keyboard uses `keyup` timing. For touch, you must decide: track duration at `touchend`, OR use a "held" boolean polled each frame.

**Why it happens:** Touch events model finger contact differently from keyboard hold state.

**How to avoid:** On `touchstart`, record `jumpHeldSince = performance.now()`. On `touchend`, compute `holdDuration = performance.now() - jumpHeldSince`. Apply jump cut if `holdDuration < 120ms`. This approximates variable height without requiring per-frame polling.

**Warning signs:** Touch always produces max-height jumps or always min-height jumps regardless of tap duration.

### Pitfall 2: Physics Explosion at Tab Switch

**What goes wrong:** When the user switches away and back, `deltaTime` can be several seconds, causing the player to teleport through the ground.

**Why it happens:** `requestAnimationFrame` pauses in background tabs, so the next frame has a massive timestamp difference.

**How to avoid:** Cap `deltaTime` at 0.1s (already done in `main.js` — keep this cap).

**Warning signs:** Player falls through ground after tab switch.

### Pitfall 3: Coyote Jump Granting Extra Jumps

**What goes wrong:** Player jumps on the last frame of coyote time, gets a jump. Then `jumpsRemaining` is decremented but the game still thinks they have 1 double-jump remaining. They can double-jump while clearly airborne after a proper first jump.

**Why it happens:** The coyote check and `jumpsRemaining` counter interact badly if not reset together.

**How to avoid:** When coyote time fires a jump, set `coyoteTimer = 0` AND decrement `jumpsRemaining` from 2 to 1 in the same operation.

**Warning signs:** Player can jump three times in a row.

### Pitfall 4: Sprite Animation Bleeding Between States

**What goes wrong:** When switching animation state (e.g., run → jump), the frame index from the previous state carries over, causing the sprite to start mid-animation or at an invalid frame index.

**Why it happens:** `currentFrame` is shared across states, but each state has different frame counts.

**How to avoid:** Reset `animFrame = 0` and `animTime = 0` whenever `animState` changes.

**Warning signs:** Sprite flickers or shows wrong frame on state transition.

### Pitfall 5: Landing Animation Not Playing Once

**What goes wrong:** The `land` animation is set to 3 frames and loops instead of playing once and transitioning to `run`.

**Why it happens:** The animation loop logic just wraps `currentFrame % totalFrames` without checking for one-shot states.

**How to avoid:** Track which states are one-shot (`land`). When `animFrame` reaches `totalFrames - 1` in a one-shot state, transition to the next state (`run`) instead of wrapping.

**Warning signs:** Zebra perpetually "squats" on landing.

### Pitfall 6: Nano Banana Sprite Inconsistency Across Frames

**What goes wrong:** AI-generated sprite sheets have inconsistent character size, pose baseline, or proportions across frames.

**Why it happens:** Generative AI doesn't guarantee pixel-perfect frame alignment.

**How to avoid:** Prompt explicitly: "consistent character size across all frames, same baseline, same proportions, transparent background, evenly spaced frames on a horizontal sprite sheet." Use Piskel or a simple image editor to manually adjust frame alignment if needed.

**Warning signs:** Character appears to jump vertically across frames during animation playback.

## Code Examples

### Complete Jump Handler

```javascript
// Source: composite from gameidea.org coyote timer + pavcreations.com variable jump

function handleJumpPress(player) {
  const canFirstJump = player.coyoteTimer > 0 && player.jumpsRemaining === 2;
  const canDoubleJump = player.jumpsRemaining === 1 && !player.isGrounded;

  if (canFirstJump) {
    player.velocityY = CONFIG.JUMP_VELOCITY;        // -650 px/s
    player.coyoteTimer = 0;
    player.jumpsRemaining = 1;
    player.animState = 'jump';
    player.animFrame = 0;
  } else if (canDoubleJump) {
    player.velocityY = CONFIG.JUMP_VELOCITY * CONFIG.DOUBLE_JUMP_MULT;  // -552 px/s
    player.jumpsRemaining = 0;
    player.animState = 'doubleJump';
    player.animFrame = 0;
  }
}

function handleJumpRelease(player) {
  if (player.velocityY < 0) {
    // Cut upward velocity for short hop
    player.velocityY *= CONFIG.JUMP_CUT_MULTIPLIER;  // * 0.5
  }
}
```

### Complete Physics Update

```javascript
// Source: composite from jobtalle.com physics + Phase 1 main.js deltaTime pattern

function updatePlayer(player, deltaTime) {
  // --- Horizontal movement ---
  player.x += player.velocityX * deltaTime;
  // Soft bounce at zone edges
  if (player.x < CONFIG.PLAYER_MOVE_ZONE_LEFT) {
    player.velocityX = Math.abs(player.velocityX) * CONFIG.PLAYER_BOUNCE_FORCE;
  }
  if (player.x > CONFIG.PLAYER_MOVE_ZONE_RIGHT) {
    player.velocityX = -Math.abs(player.velocityX) * CONFIG.PLAYER_BOUNCE_FORCE;
  }

  // --- Vertical physics ---
  if (!player.isGrounded) {
    // Asymmetric gravity: fall faster than rise (snappy feel)
    const gravMult = player.velocityY > 0 ? CONFIG.FALL_GRAVITY_MULT : 1.0;
    player.velocityY += CONFIG.GRAVITY * gravMult * deltaTime;
  }
  player.y += player.velocityY * deltaTime;

  // --- Ground collision ---
  const groundContact = CONFIG.GROUND_Y - CONFIG.PLAYER_HEIGHT;
  const wasGrounded = player.isGrounded;
  if (player.y >= groundContact) {
    player.y = groundContact;
    player.velocityY = 0;
    player.isGrounded = true;
    player.coyoteTimer = CONFIG.COYOTE_TIME;
    player.jumpsRemaining = 2;
    // Landing transition
    if (!wasGrounded) {
      player.animState = 'land';
      player.animFrame = 0;
      player.animTime = 0;
      player.squashX = 1.3;
      player.squashY = 0.7;
    }
  } else {
    player.isGrounded = false;
    player.coyoteTimer = Math.max(0, player.coyoteTimer - deltaTime);
  }

  // --- Squash/stretch spring back ---
  player.squashX += (1.0 - player.squashX) * 12 * deltaTime;
  player.squashY += (1.0 - player.squashY) * 12 * deltaTime;

  // --- Animation state (if not landing) ---
  updateAnimationState(player, deltaTime);
}
```

### Sprite Draw Call

```javascript
// Source: spicyyoghurt.com + MDN Canvas API

function drawPlayer(ctx, player, spriteSheet) {
  const anim = ANIM_STATES[player.animState];
  const frameW = CONFIG.PLAYER_WIDTH;
  const frameH = CONFIG.PLAYER_HEIGHT;

  const srcX = player.animFrame * frameW;
  const srcY = anim.row * frameH;

  ctx.save();
  // Anchor transform at bottom-center for natural squash/stretch
  ctx.translate(player.x + frameW / 2, player.y + frameH);
  ctx.scale(player.squashX, player.squashY);
  ctx.translate(-(frameW / 2), -frameH);

  ctx.drawImage(
    spriteSheet,
    srcX, srcY, frameW, frameH,   // source crop
    0, 0, frameW, frameH           // destination (at local 0,0 after transform)
  );

  ctx.restore();
}
```

### Nano Banana Sprite Generation Prompt

```
/generate "A cute chibi zebra character for a 2D side-scrolling runner game.
Horizontal sprite sheet with 6 animation frames showing a run cycle.
Each frame is 80x80 pixels. Transparent background.
Big head, small body, rounded shapes, expressive eyes, black and white zebra stripes.
Consistent character size and baseline across all frames. Viewed from the side."
```

Additional sheets to request:
```
/generate "Same chibi zebra character. Horizontal sprite sheet:
Frame 1: jumping up, Frame 2: peak of jump. Transparent background, 80x80px per frame."

/generate "Same chibi zebra character. Horizontal sprite sheet:
Frame 1: falling down, Frame 2: falling fast. Transparent background, 80x80px per frame."
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Fixed-step physics (frame-count based) | Delta-time physics (seconds-based) | Established practice pre-2010 | Mandatory for multi-Hz support |
| Single gravity constant | Asymmetric gravity (fall multiplier) | ~2010s platformer era | Makes jumps feel snappy vs floaty |
| Hard stop at screen edges | Soft bounce / velocity reflection | Modern UX expectation | Prevents jarring stops |
| Manual sprite art | AI generation via Nano Banana | 2025 (Gemini 2.5 Flash Image) | Dramatically faster sprite creation |
| Separate image per animation frame | Sprite sheets with 9-param drawImage | Pre-2010 standard | Single HTTP request, better performance |

**Deprecated/outdated:**
- `setInterval` for game loops: Replaced by `requestAnimationFrame` — already in use in Phase 1.
- `Image.src` per frame: Single sprite sheet with 9-param `drawImage` is standard — use this approach.

## Open Questions

1. **Nano Banana output quality for pixel-art chibi**
   - What we know: Nano Banana generates PNG images from text prompts; sprite sheets are supported; output saved to `./nanobanana-output/`
   - What's unclear: Whether chibi pixel-art style with consistent frame alignment is achievable in one prompt, or whether manual cleanup in Piskel will always be needed
   - Recommendation: Generate a test sheet early in the task. If frames are misaligned, use Piskel to correct. Build 15-30 minutes of cleanup time into the sprite task.

2. **Workshop reproducibility of AI sprite generation**
   - What we know: Gemini API key is required; the workshop audience needs to follow along
   - What's unclear: Whether workshop participants will all have Gemini API keys, or if a pre-generated sprite sheet should be committed to the repo as a fallback
   - Recommendation: Commit a reference sprite sheet to the repo. Document the generation prompt. Workshop participants can optionally regenerate or use the committed sheet.

3. **Touch variable jump height feel**
   - What we know: `touchend` provides hold duration; cutoff at ~120ms can approximate tap vs hold
   - What's unclear: Whether 120ms is the right threshold for mobile feel or needs tuning
   - Recommendation: Start with 120ms. Add it to CONFIG as `TOUCH_JUMP_SHORT_MS: 120` so it's tunable from browser console during workshop.

4. **Double-jump visual feedback**
   - What we know: A separate `doubleJump` animation row should be included in the sprite sheet
   - What's unclear: Whether a visual particle/flash effect (spark or flip) is needed in addition to the animation frame change
   - Recommendation: Use the animation state change alone for Phase 2. Particle effects are Phase 6 scope.

## Sources

### Primary (HIGH confidence)
- `https://ai.google.dev/gemini-api/docs/image-generation` — Nano Banana model names, API usage
- `https://deepwiki.com/gemini-cli-extensions/nanobanana/2.1-installation` — Installation steps, commands, API key setup
- `https://spicyyoghurt.com/tutorials/html5-javascript-game-development/images-and-sprite-animations` — drawImage 9-param API, animation timing with delta time
- MDN Canvas API (browser standard) — drawImage, ctx.save/scale/restore

### Secondary (MEDIUM confidence)
- `https://gameidea.org/2025/08/02/make-platformer-jump-feel-satisfying-using-coyote-timer/` — Coyote timer implementation (GDScript, ported to JS pattern)
- `https://pavcreations.com/jumping-controls-in-2d-pixel-perfect-platformers/` — Variable jump height via gravity multipliers (C#, pattern is language-agnostic)
- `https://jobtalle.com/2d_platformer_physics.html` — Delta-time Euler integration formulas
- `https://www.gamemakerkitchen.com/tutorials/jordan-guillou/10-levels-of-platformer-jumps/` — 10 levels of jump mechanics, coyote time and input buffering principles
- `https://lab.rosebud.ai/blog/how-to-create-a-sprite-sheet-with-ai-using-google-gemini-and-nano-banana-easy-guide` — Sprite sheet generation workflow with Nano Banana

### Tertiary (LOW confidence)
- WebSearch results on character sizing: No authoritative source gave exact pixel dimensions for side-scrolling runner characters. The 64x80 recommendation is derived from proportional reasoning (10-15% of play area height) cross-referenced with Chrome Dino game proportions.
- Double-jump implementation patterns: Primarily from Phaser/Godot examples; ported to vanilla JS pattern. Verify against actual behavior during implementation.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — No external libraries needed; Canvas 2D API is browser-native; Nano Banana confirmed via official Google AI docs
- Physics patterns: MEDIUM-HIGH — Core physics verified via multiple sources; specific values (FALL_GRAVITY_MULT: 1.6, JUMP_CUT_MULTIPLIER: 0.5) are starting points requiring feel-tuning
- Sprite animation: HIGH — 9-param drawImage and state machine pattern are well-established Canvas 2D standards
- Character sizing: MEDIUM — Derived from proportional reasoning; no single authoritative source for exact dimensions
- Nano Banana workflow: MEDIUM — Installation confirmed; sprite quality for chibi pixel art unverified until tested

**Research date:** 2026-02-18
**Valid until:** 2026-03-20 (Nano Banana is fast-moving; re-verify CLI extension docs if >30 days old)
