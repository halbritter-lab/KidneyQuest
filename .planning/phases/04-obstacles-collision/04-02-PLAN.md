---
phase: 04-obstacles-collision
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - js/main.js
  - js/renderer.js
autonomous: false

must_haves:
  truths:
    - "Hitting an obstacle triggers a brief death animation with player flashing and screen shaking"
    - "After the death animation, a semi-transparent overlay shows Game Over, the score (distance in meters), and which obstacle type ended the run"
    - "Collision detection uses a shrunk hitbox so near-misses feel exciting, not unfair"
    - "A subtle yellow flash appears on the player when narrowly avoiding an obstacle"
    - "Space during the death animation is ignored; Space after cooldown restarts the game"
    - "Restarting fully resets obstacles, score, and player to a clean READY state"
  artifacts:
    - path: "js/main.js"
      provides: "AABB collision check, near-miss detection, DYING state with deathTimer, triggerDeath function, nearMissTimer, extended game over with killerObstacleName"
      contains: "aabbOverlap"
    - path: "js/renderer.js"
      provides: "drawWithShake for screen shake, drawGameOverOverlay with killer obstacle name, near-miss flash rendering"
      contains: "drawWithShake"
  key_links:
    - from: "js/main.js"
      to: "aabbOverlap"
      via: "collision check in RUNNING state compares player hitbox against each obstacle hitbox"
      pattern: "aabbOverlap.*playerHitbox.*obsHitbox"
    - from: "js/main.js"
      to: "DYING state"
      via: "collision triggers DYING, deathTimer counts up, transitions to GAME_OVER after DEATH_ANIMATION_DURATION"
      pattern: "gameState.*DYING|DYING.*deathTimer"
    - from: "js/main.js"
      to: "js/renderer.js"
      via: "DYING state calls drawWithShake wrapping all draw calls for screen shake effect"
      pattern: "drawWithShake"
    - from: "js/renderer.js"
      to: "killerObstacleName"
      via: "game over overlay displays the displayName of the obstacle that killed the player"
      pattern: "killerObstacleName|Hit a"
---

<objective>
Implement AABB collision detection with per-type hitbox shrink, near-miss detection with yellow flash, the DYING state with death animation (player flash + screen shake), and the game over overlay showing score and killer obstacle name. Wire restart to fully reset the game.

Purpose: This plan completes the obstacle threat loop. After this plan, obstacles are dangerous -- hitting one triggers a visually satisfying death sequence and game over screen. The forgiving hitbox shrink makes near-misses feel exciting rather than unfair, and the near-miss flash adds a rush of "that was close!" moments. Combined with Plan 01's spawning, this delivers the full Phase 4 experience.

Output: Complete collision -> death -> game over -> restart loop with all visual effects.
</objective>

<execution_context>
@C:\Users\bernt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\bernt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-obstacles-collision/04-CONTEXT.md
@.planning/phases/04-obstacles-collision/04-RESEARCH.md
@.planning/phases/04-obstacles-collision/04-01-SUMMARY.md

@js/config.js
@js/main.js
@js/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement collision detection, near-miss, DYING state, and death animation</name>
  <files>js/main.js, js/renderer.js</files>
  <action>
Read the current js/main.js and js/renderer.js first. Plan 01 will have added obstacle spawning, updateSpawning, updateObstacles, drawObstacles, and the obstacles array. Phase 3 will have the five-state machine with RUNNING/PAUSED/GAME_OVER states. Understand the current code structure before modifying.

**In js/main.js -- Add collision and death logic:**

Add these module-level state variables (alongside existing obstacle state from Plan 01):

```javascript
// Collision and death state (Phase 4 Plan 02)
let deathTimer = 0;
let killerObstacleName = null;
let nearMissTimer = 0;
```

Add these helper functions:

1. `getHitbox(entity, shrinkFraction)` -- returns a shrunk bounding box:
```javascript
function getHitbox(entity, shrinkFraction) {
  const sx = entity.width * shrinkFraction;
  const sy = entity.height * shrinkFraction;
  return {
    x: entity.x + sx,
    y: entity.y + sy,
    width: entity.width - 2 * sx,
    height: entity.height - 2 * sy,
  };
}
```

2. `aabbOverlap(a, b)` -- standard AABB overlap test:
```javascript
function aabbOverlap(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}
```

3. `checkCollisions(player)` -- checks all obstacles for collision AND near-miss:
```javascript
function checkCollisions(player) {
  const playerHitbox = getHitbox(
    { x: player.x, y: player.y, width: CONFIG.PLAYER_WIDTH, height: CONFIG.PLAYER_HEIGHT },
    CONFIG.PLAYER_HITBOX_SHRINK
  );

  for (const obs of obstacles) {
    const obsHitbox = getHitbox(obs, obs.hitboxShrink);
    if (aabbOverlap(playerHitbox, obsHitbox)) {
      return { collision: obs, nearMiss: false };
    }
  }

  // No collision -- check for near-miss (visual bounds overlap but hitbox didn't)
  const playerVisual = { x: player.x, y: player.y, width: CONFIG.PLAYER_WIDTH, height: CONFIG.PLAYER_HEIGHT };
  for (const obs of obstacles) {
    const obsVisual = { x: obs.x, y: obs.y, width: obs.width, height: obs.height };
    if (aabbOverlap(playerVisual, obsVisual)) {
      return { collision: null, nearMiss: true };
    }
  }

  return { collision: null, nearMiss: false };
}
```

4. `triggerDeath(obstacle)` -- transitions to DYING state:
```javascript
function triggerDeath(obstacle) {
  deathTimer = 0;
  killerObstacleName = obstacle.displayName;
  gameState = 'DYING';
}
```

**Add DYING state to the game loop:**

The game loop currently handles READY, COUNTDOWN, RUNNING, PAUSED, GAME_OVER. Add a DYING state branch. The DYING state:

- Updates deathTimer: `deathTimer += deltaTime`
- Does NOT update obstacles (they freeze)
- Does NOT update spawning
- Does NOT update distance
- When `deathTimer >= CONFIG.DEATH_ANIMATION_DURATION`, transitions to GAME_OVER: set `gameState = 'GAME_OVER'`, reset `gameOverTimer = 0` (or whatever the Phase 3 game over timer variable is called)

For rendering in DYING state, all game content (ground, obstacles, player) must be drawn inside a screen shake wrapper. The player flashes on/off based on deathTimer:

```javascript
// DYING state in game loop:
if (gameState === 'DYING') {
  deathTimer += deltaTime;

  if (deathTimer >= CONFIG.DEATH_ANIMATION_DURATION) {
    gameState = 'GAME_OVER';
    gameOverTimer = 0;
  }

  // Render with screen shake
  drawWithShake(ctx, CONFIG, deathTimer, () => {
    drawGround(ctx, CONFIG, groundOffset);
    drawObstacles(ctx, obstacles);

    // Player flash: visible every other DEATH_FLASH_INTERVAL
    const flashVisible = Math.floor(deathTimer / CONFIG.DEATH_FLASH_INTERVAL) % 2 === 0;
    if (flashVisible) {
      drawPlayer(ctx, player, CONFIG);
    }

    drawHUD(ctx, CONFIG, distance);
  });
}
```

**Wire collision check into RUNNING state:**

In the RUNNING state, AFTER updateObstacles and BEFORE drawing, add collision and near-miss checks:

```javascript
// After updateSpawning and updateObstacles in RUNNING state:
const result = checkCollisions(player);
if (result.collision) {
  triggerDeath(result.collision);
  // Skip the rest of RUNNING rendering -- the DYING state will handle the next frame
} else {
  if (result.nearMiss && nearMissTimer <= 0) {
    nearMissTimer = CONFIG.NEAR_MISS_FLASH_DURATION;
  }
  // ... continue with normal RUNNING rendering ...
}
```

Update nearMissTimer each frame in RUNNING state: `if (nearMissTimer > 0) nearMissTimer -= deltaTime;`

**Near-miss rendering in RUNNING state:**

When `nearMissTimer > 0` during RUNNING, draw a brief yellow flash on the player. The simplest approach: after drawPlayer, if nearMissTimer > 0, draw a semi-transparent yellow overlay rect at the player position:

```javascript
// After drawPlayer in RUNNING state:
if (nearMissTimer > 0) {
  ctx.save();
  ctx.globalAlpha = 0.4;
  ctx.fillStyle = CONFIG.NEAR_MISS_FLASH_COLOR;
  ctx.fillRect(
    Math.round(player.x),
    Math.round(player.y),
    CONFIG.PLAYER_WIDTH,
    CONFIG.PLAYER_HEIGHT
  );
  ctx.restore();
}
```

**Update handleAction for DYING state:**

In the handleAction function, DYING state should be ignored (no input accepted during death animation). Ensure the GAME_OVER branch only accepts restart after the cooldown has passed. The Phase 3 implementation likely already has the cooldown check, but verify it works correctly with the new flow where DYING precedes GAME_OVER.

**Extend resetGame:**

Add to the existing resetGame function (which already clears obstacles from Plan 01):
```javascript
deathTimer = 0;
killerObstacleName = null;
nearMissTimer = 0;
```

**In js/renderer.js -- Add drawWithShake and update game over overlay:**

1. Add `drawWithShake(ctx, config, deathTimer, drawFn)` -- screen shake wrapper:
```javascript
export function drawWithShake(ctx, config, deathTimer, drawFn) {
  const duration = config.DEATH_SHAKE_DURATION;
  const amplitude = config.SHAKE_AMPLITUDE;

  if (deathTimer >= duration) {
    drawFn();
    return;
  }

  const progress = deathTimer / duration;
  const currentAmplitude = amplitude * (1.0 - progress);

  const dx = (Math.random() * 2 - 1) * currentAmplitude;
  const dy = (Math.random() * 2 - 1) * currentAmplitude * 0.6;

  ctx.save();
  ctx.translate(Math.round(dx), Math.round(dy));
  drawFn();
  ctx.restore();
}
```

Math.round prevents sub-pixel blurring. Vertical shake is 60% of horizontal (less disorienting). Linear decay from full amplitude to zero.

2. Update the existing `drawGameOver` function (from Phase 3) OR add a new `drawGameOverOverlay` function. The Phase 3 version shows "Game Over" text and pulsing restart prompt. Extend it to also display:
   - The killer obstacle name: `"Hit a ${killerObstacleName}!"` in orange (#FFAA44), positioned below "Game Over"
   - The score as distance: `"Distance: ${Math.floor(distance / CONFIG.PX_PER_METER)}m"` in white
   - A semi-transparent dark overlay (`rgba(0, 0, 0, ${CONFIG.GAME_OVER_OVERLAY_ALPHA})`) covering the frozen game state BEFORE drawing text

The function signature should accept the additional parameters it needs. Update the call site in main.js accordingly.

If Phase 3's drawGameOver already has a different signature, adapt to extend it rather than replace it. The key additions are:
- Semi-transparent overlay backdrop
- Killer obstacle name text
- Distance score text

**Add drawWithShake to the renderer.js exports.** Update the import in main.js to include drawWithShake.

IMPORTANT: The DYING state is new -- it goes between RUNNING and GAME_OVER. Do NOT skip the death animation. The transition is: RUNNING (collision detected) -> DYING (0.5s flash+shake) -> GAME_OVER (overlay with score).

IMPORTANT: handleAction must ignore input during DYING state. The GAME_OVER cooldown timer starts when GAME_OVER begins (after DYING ends), not when the collision happens.

IMPORTANT: Do NOT import from legacy js/collision.js, js/obstacle.js, or js/game.js.
  </action>
  <verify>
Read js/main.js and confirm:
1. Contains `getHitbox`, `aabbOverlap`, `checkCollisions`, `triggerDeath` functions
2. `checkCollisions` uses `CONFIG.PLAYER_HITBOX_SHRINK` for player and `obs.hitboxShrink` for obstacles
3. `aabbOverlap` has 4 comparison conditions (standard AABB)
4. Contains `let deathTimer`, `let killerObstacleName`, `let nearMissTimer` state variables
5. Game loop has a DYING state branch with `deathTimer += deltaTime`
6. DYING state transitions to GAME_OVER when `deathTimer >= CONFIG.DEATH_ANIMATION_DURATION`
7. DYING state calls `drawWithShake` wrapping all draw calls
8. DYING state flashes player visibility based on `CONFIG.DEATH_FLASH_INTERVAL`
9. RUNNING state calls `checkCollisions` after updating obstacles
10. Near-miss renders yellow overlay on player when `nearMissTimer > 0`
11. handleAction ignores DYING state (no input accepted)
12. resetGame clears deathTimer, killerObstacleName, nearMissTimer
13. No imports from collision.js, obstacle.js, or game.js

Read js/renderer.js and confirm:
1. Contains `export function drawWithShake(ctx, config, deathTimer, drawFn)`
2. drawWithShake uses `ctx.save()`, `ctx.translate(dx, dy)`, `drawFn()`, `ctx.restore()`
3. drawWithShake applies linear decay: `amplitude * (1.0 - progress)`
4. Game over rendering includes semi-transparent overlay, "Game Over" text, killer obstacle name, score distance, and pulsing restart prompt

Open index.html in browser:
1. Start the game, let obstacles spawn
2. Intentionally collide with an obstacle
3. Death animation plays: player flashes on/off, screen shakes briefly (~0.5s)
4. After animation, game over overlay appears with dark backdrop
5. "Game Over" in red, "Hit a Kidney Stone!" (or whichever type) in orange, distance score in white
6. Pulsing "Press Space to Play Again" appears after cooldown
7. Press Space -- game fully resets (obstacles cleared, score reset, back to READY)
8. Near-miss: run close to an obstacle without hitting it -- brief yellow flash on player
9. No console errors
  </verify>
  <done>AABB collision detection with per-type hitbox shrink implemented. Near-miss detection triggers yellow player flash. DYING state plays 0.5s death animation with player flash and screen shake. Game over overlay shows semi-transparent backdrop, "Game Over" text, killer obstacle name, distance score, and pulsing restart prompt. Full restart resets all state cleanly.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 4: Obstacles + Collision. Three obstacle types (kidney stone, toxin, salt crystal) spawn progressively, scroll left, and create a dangerous game world. AABB collision with forgiving hitbox shrink detects hits. Near-misses produce a yellow flash. Collision triggers a death animation (player flash + screen shake) followed by a game over overlay showing score and which obstacle killed the player. Full restart loop works.</what-built>
  <how-to-verify>
1. Open http://localhost:8080 (or serve with `npx http-server -p 8080 -c-1`)
2. Press Space to start -- countdown plays, then game begins
3. Observe brown kidney stone obstacles spawning from the right and scrolling left
4. After ~10 seconds, green toxin obstacles should also appear
5. After ~20 seconds, light-blue salt crystal obstacles should appear ABOVE ground level (floating)
6. Run close to an obstacle without hitting it -- you should see a brief yellow flash on the player (near-miss)
7. Intentionally collide with an obstacle:
   a. Screen shakes briefly, player flashes on/off
   b. After ~0.5 seconds, dark overlay appears
   c. "Game Over" in red
   d. "Hit a [Obstacle Name]!" showing which type you hit
   e. Distance score displayed
   f. After ~1-2 seconds, pulsing "Press Space to Play Again" appears
8. Press Space -- game fully resets (obstacles gone, score zero, back to start screen)
9. Play again and verify it feels fair (near-misses should survive, not feel like BS deaths)
10. Open console: type `CONFIG.SPAWN_BASE_INTERVAL = 0.3` -- obstacles spawn much faster
11. Open console: type `CONFIG.OBSTACLE_TYPES[0].hitboxShrink = 0.5` -- kidney stones become very forgiving
12. Verify no console errors throughout
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with collision feel, death animation, obstacle pacing, or visual appearance</resume-signal>
</task>

</tasks>

<verification>
Phase 4 success criteria (from ROADMAP.md):
1. Rectangle obstacles spawn at intervals on the right side and scroll left toward the player
2. Multiple obstacle types (kidney stone, toxin, salt crystal) appear with different sizes, defined in config
3. Hitting an obstacle immediately triggers game over -- the game stops and shows a final score
4. Collision detection uses AABB with a forgiving hitbox shrink so near-misses feel good

Additional criteria from CONTEXT.md decisions:
5. Both ground-level and floating obstacles present
6. Progressive type introduction (stones -> toxins -> salt crystals)
7. Brief death animation (~0.5s) with player flash and screen shake before game over
8. Game over overlay shows score AND which obstacle type ended the run
9. Near-miss yellow flash on survived close calls
10. Basic restart via Space on game over screen
</verification>

<success_criteria>
1. Three obstacle types visible with distinct colors and sizes
2. Collision triggers DYING -> GAME_OVER sequence (not instant game over)
3. Death animation includes visible player flash and screen shake
4. Game over overlay shows "Hit a [type]!" with the correct obstacle name
5. Near-miss produces brief yellow flash when surviving a close call
6. Hitbox shrink makes gameplay feel fair (near-misses survive)
7. Full restart loop works cleanly (no leftover state)
8. All collision/timing values tunable via CONFIG
9. Zero console errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-obstacles-collision/04-02-SUMMARY.md`
</output>
